[03-09-2025 22:41] Sameer: #include <iostream>
#include <map>
#include <vector>
#include <string>
#include <sstream>
using namespace std;

map<string, vector<vector<string>>> grammar;
string startSymbol;
vector<string> tokens;

bool isNonTerminal(const string &symbol) {
    return grammar.find(symbol) != grammar.end();
}

pair<bool, int> parse(const string &nonTerminal, int pos) {
    if (pos > (int)tokens.size()) return {false, pos};

    for (auto &production : grammar[nonTerminal]) {
        int curPos = pos;
        bool matched = true;

        for (auto &symbol : production) {
            if (symbol == "ε") continue;  // epsilon case

            else if (isNonTerminal(symbol)) {
                auto res = parse(symbol, curPos);
                if (!res.first) {
                    matched = false;
                    break;
                }
                curPos = res.second;
            } 
            else {
                if (curPos < (int)tokens.size() && tokens[curPos] == symbol) {
                    curPos++;
                } else {
                    matched = false;
                    break;
                }
            }
        }

        if (matched) return {true, curPos};
    }
    return {false, pos};
}

vector<string> tokenize(const string &input) {
    vector<string> result;
    stringstream ss(input);
    string temp;
    while (ss >> temp) result.push_back(temp);
    return result;
}

int main() {
    int n;
    cout << "Enter number of non-terminals: ";
    cin >> n;
    cin.ignore();

    for (int i = 0; i < n; i++) {
        string nonTerminal;
        cout << "Enter non-terminal " << (i + 1) << ": ";
        getline(cin, nonTerminal);

        if (i == 0) startSymbol = nonTerminal;

        int p;
        cout << "Enter number of productions for <" << nonTerminal << ">: ";
        cin >> p;
        cin.ignore();

        for (int j = 0; j < p; j++) {
            string prodLine;
            cout << "Enter production " << (j + 1) 
                 << " (tokens separated by space, use ε for epsilon): ";
            getline(cin, prodLine);

            vector<string> production = tokenize(prodLine);
            grammar[nonTerminal].push_back(production);
        }
    }

    cout << "\nStart symbol is: " << startSymbol << "\n";
    cout << "Enter input string tokens separated by space: ";
    string inputLine;
    getline(cin, inputLine);

    tokens = tokenize(inputLine);

    auto res = parse(startSymbol, 0);

    if (res.first && res.second == (int)tokens.size())
        cout << "✅ String is accepted by the grammar.\n";
    else
        cout << "❌ String is NOT accepted by the grammar.\n";

    return 0;
}
[03-09-2025 22:41] Sameer: #3 WAP to check if string can be generated by grammar
/*
Output
Enter number of non-terminals: 2
Enter non-terminal 1: E
Enter number of productions for <E>: 2
Enter production 1 (tokens separated by space, use ε for epsilon): E+T
Enter production 2 (tokens separated by space, use ε for epsilon): T
Enter non-terminal 2: T
Enter number of productions for <T>: 1
Enter production 1 (tokens separated by space, use ε for epsilon): id

Start symbol is: E
Enter input string tokens separated by space: id * id
❌ String is NOT accepted by the grammar.
*/
[03-09-2025 22:50] Sameer: #include <iostream>
#include <vector>
#include <string>
using namespace std;

struct Production {
    string nonTerminal;
    vector<string> rhs;
};

int main() {
    int n;
    cout << "Enter number of non-terminals: ";
    cin >> n;
    cin.ignore();

    vector<Production> grammar(n);

    // Input grammar
    for (int i = 0; i < n; i++) {
        cout << "Enter non-terminal " << i + 1 << ": ";
        cin >> grammar[i].nonTerminal;
        int p;
        cout << "Enter number of productions for " << grammar[i].nonTerminal << ": ";
        cin >> p;
        cin.ignore();
        cout << "Enter productions separated by space (use '|' for alternatives):\n";
        string line;
        getline(cin, line);

        string temp = "";
        for (char c : line) {
            if (c == '|') {
                grammar[i].rhs.push_back(temp);
                temp = "";
            } else {
                temp += c;
            }
        }
        if (!temp.empty()) grammar[i].rhs.push_back(temp);
    }

    cout << "\n--- Removing Left Recursion ---\n";
    for (auto &prod : grammar) {
        string A = prod.nonTerminal;
        vector<string> alpha, beta;

        // Split into alpha (starts with A) and beta (does not)
        for (auto &rule : prod.rhs) {
            if (rule[0] == A[0]) {
                alpha.push_back(rule.substr(1));  // remove leading A
            } else {
                beta.push_back(rule);
            }
        }

        if (!alpha.empty()) {
            // Left recursion exists
            string Aprime = A + "'";
            cout << A << " -> ";
            for (int i = 0; i < (int)beta.size(); i++) {
                cout << beta[i] << Aprime;
                if (i != (int)beta.size() - 1) cout << " | ";
            }
            cout << endl;

            cout << Aprime << " -> ";
            for (int i = 0; i < (int)alpha.size(); i++) {
                cout << alpha[i] << Aprime << " | ";
            }
            cout << "ε" << endl;
        } else {
            // No left recursion
            cout << A << " -> ";
            for (int i = 0; i < (int)prod.rhs.size(); i++) {
                cout << prod.rhs[i];
                if (i != (int)prod.rhs.size() - 1) cout << " | ";
            }
            cout << endl;
        }
    }

    return 0;
}
/*
Enter number of non-terminals: 1
Enter non-terminal 1: E
Enter number of productions for E: 2
Enter productions separated by space (use '|' for alternatives):
E+T | T

--- Removing Left Recursion ---
E ->  TE'
E' -> +T E' | ε

*/
[03-09-2025 22:52] Sameer: #4 remove left recursion
[03-09-2025 22:58] Sameer: #include <iostream>
#include <map>
#include <vector>
#include <set>
#include <string>
#include <sstream>
using namespace std;

map<string, vector<vector<string>>> grammar;
map<string, set<string>> first;

bool isTerminal(const string &symbol) {
    return grammar.find(symbol) == grammar.end();
}

void computeFirst() {
    bool changed = true;
    while (changed) {
        changed = false;
        for (auto &nt : grammar) {
            string nonTerminal = nt.first;
            for (auto &production : nt.second) {
                bool epsilonInAll = true;
                for (auto &symbol : production) {
                    if (isTerminal(symbol)) {
                        if (first[nonTerminal].insert(symbol).second)
                            changed = true;
                        epsilonInAll = false;
                        break;
                    } else {
                        for (auto &s : first[symbol]) {
                            if (s != "ε") {
                                if (first[nonTerminal].insert(s).second)
                                    changed = true;
                            }
                        }
                        if (first[symbol].find("ε") == first[symbol].end()) {
                            epsilonInAll = false;
                            break;
                        }
                    }
                }
                if (epsilonInAll) {
                    if (first[nonTerminal].insert("ε").second)
                        changed = true;
                }
            }
        }
    }
}

void printFirstSets() {
    for (auto &nt : first) {
        cout << "FIRST(" << nt.first << ") = { ";
        for (auto it = nt.second.begin(); it != nt.second.end(); it++) {
            cout << *it;
            auto nxt = it;
            nxt++;
            if (nxt != nt.second.end()) cout << ", ";
        }
        cout << " }" << endl;
    }
}

int main() {
    // Example Grammar from notes:
    grammar["E"] = { {"T", "E'"} };
    grammar["E'"] = { {"+", "T", "E'"}, {"ε"} };
    grammar["T"] = { {"F", "T'"} };
    grammar["T'"] = { {"*", "F", "T'"}, {"ε"} };
    grammar["F"] = { {"(", "E", ")"}, {"id"} };

    computeFirst();
    printFirstSets();

    return 0;
}
[03-09-2025 22:58] Sameer: #5 find first
[03-09-2025 23:02] Sameer: #include <iostream>
#include <map>
#include <vector>
#include <string>
using namespace std;

struct Production {
    string nonTerminal;
    vector<string> rhs;
};

// Function to find longest common prefix among RHS
string longestCommonPrefix(const vector<string>& prods) {
    if (prods.empty()) return "";
    string prefix = prods[0];
    for (int i = 1; i < prods.size(); i++) {
        int j = 0;
        while (j < prefix.size() && j < prods[i].size() && prefix[j] == prods[i][j])
            j++;
        prefix = prefix.substr(0, j);
    }
    return prefix;
}

int main() {
    int n;
    cout << "Enter number of non-terminals: ";
    cin >> n;
    cin.ignore();

    vector<Production> grammar(n);

    // Input grammar
    for (int i = 0; i < n; i++) {
        cout << "Enter non-terminal " << i + 1 << ": ";
        cin >> grammar[i].nonTerminal;
        int p;
        cout << "Enter number of productions for " << grammar[i].nonTerminal << ": ";
        cin >> p;
        cin.ignore();

        cout << "Enter productions (without spaces, separate by | ): ";
        string line;
        getline(cin, line);

        string temp = "";
        for (char c : line) {
            if (c == '|') {
                grammar[i].rhs.push_back(temp);
                temp = "";
            } else {
                temp += c;
            }
        }
        if (!temp.empty()) grammar[i].rhs.push_back(temp);
    }

    cout << "\n--- Left Factored Grammar ---\n";
    for (auto &prod : grammar) {
        string A = prod.nonTerminal;
        string prefix = longestCommonPrefix(prod.rhs);

        if (prefix.size() > 0 && prefix.size() < prod.rhs[0].size()) {
            string Aprime = A + "'";
            cout << A << " -> " << prefix << Aprime << endl;
            cout << Aprime << " -> ";
            for (int i = 0; i < prod.rhs.size(); i++) {
                string suffix = prod.rhs[i].substr(prefix.size());
                if (suffix == "") suffix = "ε";
                cout << suffix;
                if (i != prod.rhs.size() - 1) cout << " | ";
            }
            cout << endl;
        } else {
            cout << A << " -> ";
            for (int i = 0; i < prod.rhs.size(); i++) {
                cout << prod.rhs[i];
                if (i != prod.rhs.size() - 1) cout << " | ";
            }
            cout << endl;
        }
    }

    return 0;
}
/*Enter number of non-terminals: 1
Enter non-terminal 1: A
Enter number of productions for A: 3
Enter productions (without spaces, separate by | ): abc|abd|aef

--- Left Factored Grammar ---
A -> aA'
A' -> bc | bd | ef*/

[03-09-2025 23:02] Sameer: #6 Find left factor

[17-09-2025 14:52] Sameer: 
#include <iostream>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

map<char, set<char>> first_sets;
map<char, set<char>> follow_sets;
map<char, vector<string>> grammar;
set<char> non_terminals;
char start_symbol;

bool isNonTerminal(char c) {
    return non_terminals.find(c) != non_terminals.end();
}

void computeFirst() {
    bool changed = true;

    while (changed) {
        changed = false;

        for (auto& rule : grammar) {
            char lhs = rule.first;

            for (string& prod : rule.second) {
                if (prod == "e") {
                    if (first_sets[lhs].find('e') == first_sets[lhs].end()) {
                        first_sets[lhs].insert('e');
                        changed = true;
                    }
                } else {
                    char first_sym = prod[0];

                    if (!isNonTerminal(first_sym)) {
                        // Terminal
                        if (first_sets[lhs].find(first_sym) == first_sets[lhs].end()) {
                            first_sets[lhs].insert(first_sym);
                            changed = true;
                        }
                    } else {
                        // Non-terminal
                        int before = first_sets[lhs].size();
                        for (char c : first_sets[first_sym]) {
                            if (c != 'e') {
                                first_sets[lhs].insert(c);
                            }
                        }
                        if (first_sets[lhs].size() > before) {
                            changed = true;
                        }
                    }
                }
            }
        }
    }
}

void computeFollow() {
    // Rule 1: Add $ to start symbol
    follow_sets[start_symbol].insert('$');

    bool changed = true;

    while (changed) {
        changed = false;

        for (auto& rule : grammar) {
            char lhs = rule.first;

            for (string& prod : rule.second) {
                if (prod == "e") continue;

                for (int i = 0; i < prod.length(); i++) {
                    char symbol = prod[i];

                    if (isNonTerminal(symbol)) {
                        int before = follow_sets[symbol].size();

                        if (i == prod.length() - 1) {
                            // Rule 3: At end of production
                            for (char c : follow_sets[lhs]) {
                                follow_sets[symbol].insert(c);
                            }
                        } else {
                            // Rule 2: Check symbols after current
                            bool all_nullable = true;

                            for (int j = i + 1; j < prod.length(); j++) {
                                char next_sym = prod[j];

                                if (!isNonTerminal(next_sym)) {
                                    // Terminal
                                    follow_sets[symbol].insert(next_sym);
                                    all_nullable = false;
                                    break;
                                } else {
                                    // Non-terminal: Add FIRST(next_sym) - {e}
                                    for (char c : first_sets[next_sym]) {
                                        if (c != 'e') {
                                            follow_sets[symbol].insert(c);
                                        }
                                    }

                                    if (first_sets[next_sym].find('e') == first_sets[next_sym].end()) {
                                        all_nullable = false;
                                        break;
                                    }
                                }
                            }

                            // If all following symbols are nullable
                            if (all_nullable) {
                                for (char c : follow_sets[lhs]) {
                                    follow_sets[symbol].insert(c);
                                }
                            }
                        }

                        if (follow_sets[symbol].size() > before) {
                            changed = true;
                        }
                    }
                }
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    cin.ignore();

    // Read grammar productions
    for (int i = 0; i < n; i++) {
        string line;
        getline(cin, line);

        int pos = line.find("->");
        char lhs = line[0];
        string rhs = line.substr(pos + 2);

        non_terminals.insert(lhs);

        if (i == 0) {
            start_symbol = lhs;
        }

        grammar[lhs].push_back(rhs);
    }

    // Compute FIRST sets
    computeFirst();

    // Compute FOLLOW sets
    computeFollow();

    // Print FOLLOW sets
    vector<char> sorted_nts(non_terminals.begin(), non_terminals.end());
    sort(sorted_nts.begin(), sorted_nts.end());

    for (char nt : sorted_nts) {
        cout << "FOLLOW(" << nt << ") = { ";

        vector<char> follow_vec;
        for (char c : follow_sets[nt]) {
            follow_vec.push_back(c);
        }

        // Sort: $ first, then ), then others
        sort(follow_vec.begin(), follow_vec.end(), [](char a, char b) {
            if (a == '$') return true;
            if (b == '$') return false;
            if (a == ')') return true;
            if (b == ')') return false;
            return a < b;
        });

        for (int i = 0; i < follow_vec.size(); i++) {
            cout << follow_vec[i];
            if (i < follow_vec.size() - 1) cout << " ";
        }

        cout << " }" << endl;
    }

    return 0;
}

/*
4
E->E+T
E->T
T->T*F
T->F
FOLLOW(E) = { $ }
FOLLOW(T) = { $ }
*/
[17-09-2025 14:52] Sameer: #7 follow of given grammar
[17-09-2025 14:55] Sameer: #include <bits/stdc++.h>
using namespace std;

struct Production {
    char lhs;
    string rhs;
};

int main() {
    int n;
    cout << "Enter number of productions: ";
    cin >> n;

    vector<Production> grammar(n);
    cout << "Enter productions (example: E->E+T):\n";
    for (int i = 0; i < n; i++) {
        string prod;
        cin >> prod;
        grammar[i].lhs = prod[0];
        grammar[i].rhs = prod.substr(3);
    }

    string input;
    cout << "Enter input string (end with $): ";
    cin >> input;

    string stack = "";
    int ptr = 0;

    cout << "\nStack\tInput\tAction\n";
    while (true) {
        cout << stack << "\t" << input.substr(ptr) << "\t";

        bool reduced = false;
        for (auto &prod : grammar) {
            int len = prod.rhs.size();
            if (stack.size() >= len && stack.substr(stack.size() - len) == prod.rhs) {
                stack.erase(stack.size() - len);
                stack.push_back(prod.lhs);
                cout << "Reduce by " << prod.lhs << "->" << prod.rhs << "\n";
                reduced = true;
                break;
            }
        }
        if (reduced) continue;

        if (ptr < input.size()) {
            stack.push_back(input[ptr++]);
            cout << "Shift\n";
        } else if (stack == string(1, grammar[0].lhs) && ptr == input.size()) {
            cout << "Accept\n";
            break;
        } else {
            cout << "Error\n";
            break;
        }
    }
    return 0;
}
/*
Enter number of productions: 4
Enter productions (example: E->E+T):
E->E+T
E->T
T->T*F
T->F
Enter input string (end with $): id$

Stack	Input	Action
	id$	Shift
i	d$	Shift
id	$	Shift
id$		Error

*/
[17-09-2025 14:55] Sameer: #8 shift reduce parsing from a string
